---
import FormStyles from './Form.module.css';
import { p, _parseRecords } from '../lib/getRecords'
import { useSanityClient } from 'astro-sanity';

type RecordUpload = {
    _type: string;
    name: string;
    description: string;
    records: string[];
}

// import { parse } from 'csv-parse/.';

const token = import.meta.env.SANITY_TOKEN;
const t = (obj:unknown) => Object.prototype.toString.call(obj)

if (Astro.request.method === 'POST') {
    const client = useSanityClient();

    const _result = Object.assign({}, ...Array.from((await Astro.request.formData()).entries(), ([key, value]) => ({ [key]: value as string })));
    // console.log(_result);

    const { name, description, records } = _result;
    
    // const _chunkRecords = records.split(';');
    // console.log(_chunkRecords[0]);
    
    const result = await client.create<RecordUpload>({
        _type: 'collection',
        name,
        description,
        records: []
    }, {
        token
    });
    if (records !== undefined) {
        // console.log(records);
        // console.log(records[records.length - 1] === 'P');
        // const _parsed = JSON.parse(records);
        // console.log(_parsed);
        /*
        await Promise.all(JSON.parse(records).map(record => {
            console.log(record);
            return client.patch(result._id).insert('after', 'records', record);
        }));*/
    }

    /*
    for await (const chunk of _chunkRecords) {

        const parsedChunk = JSON.parse(chunk);

        client.patch(result._id).insert('after', 'records', [...parsedChunk]);
    }
    */
    // const file = data.get('file') as File;
    // const _file = file.clone();
    
    // const records = await _parseRecords(originalFile, 0);

    // const records = await getRecords(1);
    // const ouput = p(_records);
    /*
    const entries = [];
    for (const record of _records) {
        // const address = getAddress(record);
        
        
        entries.push(record);
    }*/
    //  data.append('file', data.get('csv'), performance.now() + 'records.csv');
    
    /** client.create returns a result object with everything created, we need to grab the id though */
    // success = result._id !== undefined ? true : false;
    // @TODO Uploading isn't working due to "Body must be either string, file, or buffer" when uploading the file
    // const uploadResults = await client.assets.upload('file', )
    // const file = data.get('file') as File;
    // console.log(Object.prototype.toString.call(file));
    /*
    const uploadResults = await client.assets.upload('file', file, {
        filename: originalFile.name
    });
    */
}
---
<form action={Astro.url.href} method="POST" enctype="multipart/form-data" class={FormStyles.gridForm}>
    <label for="name">Name
        <input type="text" name="name" id="name" -required />
    </label>
    <label for="description">Description
        <textarea name="description" id="description"></textarea>
    </label>
    <label for="csv">File (Must be .csv format, .xls will not work.);
        <input type="file" name="csv" id="csv" -required accept=".csv" />
    </label>
    <div>
        <div class="tags-list">
            <p>Select columns to be deleted before final upload.</p>
        </div>
    </div>
    <input type="hidden" name="records" id="records" />
    <div class="col-form">
        <button class="btn">Create Dataset</button>
    </div>
</form>
<script>
    /// <reference types="../../index.d.ts" />
    import Papa from 'papaparse';
    // import { Loader } from '@googlemaps/js-api-loader';

    type ParsedRecord = Record<string, string|number>;

    const patientColumnsToRemove = [
        'Age Group',
        'Work Phone',
        'Home Phone',
        'Cell Phone',
        'Characteristic',
        'Deceased',
        'Deceased Date',
        'Registration Date',
        'Registry Enabled',
        'Email',
        'Email Not Provided Reason',
        'Text Enabled',
        'Voice Enabled',
        'Web Enabled',
        'Demographic Employer Name',
        'Demographic Employment Status',
    ].map(v => 'Patient '+v);

    const employeeColumnsToRemove = [
        'Job Category',
        'Hourly Rate'
    ];

    const employerColumnsToRemove = [
        'Status',
        'Phone No',
        'Fax No',
        'E-mail',
    ].map(v => 'Employer '+v);

    const guarantorColumnsToRemove = [
        'Acct No',
        'Name',
        'Mailing Address Line 1',
        'Mailing Address Line 2',
        'Mailing City',
        'Mailing State',
        'Mailing ZIP Code',
        'Phone No'
    ].map(v => 'Guarantor '+v);

    const genericColumnsToRemove = [
        'Name',
        'Address Line 1',
        'Address Line 2',
        'City',
        'State',
        'ZIP Code',
        'Subscriber No',
        'Group Name',
        'Group No',
        'Class',
        'Insurance Group Name'
    ];

    const primaryInsurColumnsToRemove = genericColumnsToRemove.map(v => 'Primary Insurance '+v);
    const secondaryInsurColumnsToRemove = genericColumnsToRemove.map(v => 'Secondary Insurance '+v);

    const columnsToRemove = [
        ...employeeColumnsToRemove,
        ...employerColumnsToRemove,
        ...patientColumnsToRemove,
        ...guarantorColumnsToRemove,
        ...primaryInsurColumnsToRemove,
        ...secondaryInsurColumnsToRemove
    ]


    const file = document.getElementById('csv') as HTMLInputElement;
    const list = document.querySelector('.tags-list');
    const form = document.querySelector('form');
    const records = document.querySelector<HTMLInputElement>('#records');
    const _data:string[] = [];
    const _file = [];
    const _headers = [];
    let _records = [] as {}[];

    const getAddress = (record: { [index: string]: string}) => {
        const addressLine1 = record['Patient Address Line 1'];
        const addressLine2 = record['Patient Address Line 2'];
        const city = record['Patient City'];
        const state = record['Patient State'];
        const zip = record['Patient ZIP Code'];
        const country = record['Patient Country'];
        const countryCode = record['Patient Country Code'];

        return {
            addressLine1,
            addressLine2,
            city,
            state,
            zip,
            country,
            countryCode
        };
    }
    /*
    let loader = new Loader({
        apiKey: import.meta.env.PUBLIC_GOOGLE_MAPS,
        version: 'weekly'
    });
    */
    /**
     * data should not include the headers row
     */
    const generateRecords = () => {
        if (_data.length === 0) throw new Error('Missing data to transform');
        if (_headers.length === 0) throw new Error('Missing headers to transform');
        _records = _data.map((data:string[]) => {
            
            const temp = {};
            _headers.forEach((h:string, i:number) => {
                console.log({ h, exists: columnsToRemove.indexOf(h) > -1 });
                if (columnsToRemove.indexOf(h) > -1) return
                temp[h] = data[i];
            })
            return temp;
        });
        console.log(_records);
    }

    file.addEventListener('change', () => {
        if (file.files.length === 0) return;
        
        const upload = file.files[0];
        

        Papa.parse(upload, {
            complete: (results) => {
                const [headers, ...parsed] = data as string[];
                const html = [];

                for (const header of headers) {
                    html.push(`<div class="tag-button">
                        <button type="button">${header}</button>
                    </div>`);
                    _headers.push(header);
                }
                _data.push(...parsed);
                generateRecords();
                list.innerHTML = html.join('');
            }
        })
    })
    list.addEventListener('click', ({ target }) => {
        const el = (target as HTMLElement).closest('.tag-button button');

        if (!el) return;

        const index = _headers.indexOf(el.textContent);

        if (index > -1) {
            _headers.splice(index, 1);
            generateRecords();
            /*
            _records = _data.map((data:string[]) => {
                const temp = {};
                _headers.forEach((h, i) => {
                    temp[h] = data[i]
                })

                return temp;
            })
            */
        }
        /*
        if (index > -1) {
            // _data[0].splice(_data.indexOf(el.textContent), 1);
            for (const row of _data) {
                row.splice(index, 1);
                _file.push(row.join(','));
            }

            el.remove();
        }*/
    });

    const ACCT_NO = 'Patient Acct No';
    type FixAcctNumber = {
        ['Patient Acct No']: number;
        [index:string]: string|number;
    }
    const chunk = <T,>(arr: T[], size:number):T[][] => (
        arr.reduce((acc, e, i) => (i % size ? acc[acc.length - 1].push(e) : acc.push([e]), acc), [] as T[][])
    )
    

    const fixAcctNumber = (obj:FixAcctNumber) => {
        if (typeof obj[ACCT_NO] === 'string') obj[ACCT_NO] = +obj[ACCT_NO];

        return obj;
    }

    const sortByAcctNumber = (arr:FixAcctNumber[]) => {
        const records = arr.map((obj) => fixAcctNumber(obj));
        let filteredRecords = records.reduce<{}[]>((acc, curr) => {
        
            if (acc.findIndex(r => r[ACCT_NO] === curr[ACCT_NO]) === -1) {
                acc.push(curr);
            }
            return acc;
        }, []);
        filteredRecords = filteredRecords.sort((a,b) => {
            return a[ACCT_NO] - b[ACCT_NO]
        })

        return filteredRecords;
    }

    form.addEventListener('submit', async function formSubmit(e) {
        e.preventDefault();
        // console.log('before reduce', _records.length);
        _records = sortByAcctNumber(_records as FixAcctNumber[]);
        /*
        _records = _records.reduce<ParsedRecord[]>((acc: ParsedRecord[], curr:ParsedRecord) => {
            const acctNumber = +curr['Patient Acct No'];
            
            if (acc.findIndex(r => +r['Patient Acct No'] === acctNumber) === -1) {
                curr['Patient Acct No'] = acctNumber;
                acc.push(curr);
            }
            
            return acc;
        }, [])
        */
        // console.log('after reduce', _records.length)
        
        // const _groupedRecords = groupBy<ParsedRecord, string>(_records, 'Patient Acct No');
        const _chunkRecords = chunk(_records, 250)
        type ChunkedRecords = {
            'Patient Acct No': string;
            [index: string]: string;
        }
        // const _groupChunkRecords = 
        // .map(r => JSON.stringify(r));
        console.log(_chunkRecords[0]);
        records.value = JSON.stringify(_chunkRecords);
        // console.log(records.value);
        // console.log(records.value);
        // await loader.load();
        // const { Geocoder } = await google.maps.importLibrary('geocoding');
        
        // @ts-ignore
        // const { createClient } = await import('https://esm.sh/@sanity/client');

        // const client = createClient({
        //     projectId: 'ul053n8h',
        //     dataset: 'production',
        //     useCdn: true,
        //     apiVersion: '2023-05-03'
        // });

        // const fd = new FormData(form);
        /*
        fd.append('file', new Blob([_file.join(`
`)], { type: 'text/csv'}));
        console.log(fd);
        console.log(...fd.entries());
        */
       /*
        const uploadResults = await client.assets.upload('file', file.files[0], {
            filename: (document.getElementById('csv') as HTMLInputElement).files[0].name
        })
        console.log(uploadResults);
        return;*/
        
        // console.log(_records);

        // form.removeEventListener('submit', formSubmit);
        // form.submit();
    })
</script>
<style is:inline>
    summary {
        user-select: none;
    }
    summary + * {
        margin-top: 1rem;
    }
</style>